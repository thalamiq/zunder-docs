---
title: "Snapshot Generation"
description: "Generating and expanding StructureDefinition snapshots with `ferrum-snapshot`."
---

<Info>
  Spec reference: [https://hl7.org/fhir/structuredefinition.html](https://hl7.org/fhir/structuredefinition.html)
</Info>

FHIR profiles are usually distributed as [`StructureDefinition`](https://hl7.org/fhir/structuredefinition.html)
resources. Most authoring tools publish **differentials** (only "what changed"),
and may omit snapshots entirely.

Ferrum needs snapshots at runtime (validation, schema checks, codegen, etc.), so we
provide a library that can:

- **Generate** a snapshot from `base.snapshot + derived.differential`
- **Generate** a differential by comparing `derived.snapshot` to `base.snapshot`
- **Deep-expand** a snapshot for "nested" validation use cases (choice types, contentReferences, complex types)

This page documents the library and the practical caveats of generating snapshots
outside of an authoring toolchain.

## Where this is needed

Snapshots are the most convenient representation for anything that needs a full
"schema-like" view of a resource type or profile:

- **Validation**: resolve required fields, slicing rules, bindings, and invariants
- **Schema / shape checks**: determine which JSON properties are allowed at each path
- **Code generation**: enumerate elements and their effective types
- **User interfaces**: drive form generation and field hints from a resolved structure

Many packages (especially IGs) ship only differentials, and servers often want
to avoid a build step that precomputes snapshots for every profile up front.

## Terminology (Ferrum conventions)

- **Base**: the StructureDefinition referenced by `baseDefinition` (or a core type like `Patient`)
- **Derived**: a profile that constrains a base
- **Differential**: only the constrained/added elements
- **Snapshot**: the "fully merged" element list after applying base + constraints
- **Deep snapshot**: a snapshot expanded so that nested types are inlined (not an official FHIR term)

## The `ferrum-snapshot` library

The snapshot generator lives in `libs/fhir-snapshot` and builds on:

- `ferrum-models` for strongly typed FHIR data structures
- `ferrum-context` for resolving base types and referenced StructureDefinitions

### Main entry points

Most callers want one of these:

```rust
use ferrum_snapshot::{
  generate_structure_definition_snapshot,
  generate_structure_definition_differential,
  generate_deep_snapshot,
  ExpandedFhirContext,
};
```

- `generate_structure_definition_snapshot(...)`: merge `base.snapshot` + `derived.differential`
- `generate_structure_definition_differential(...)`: compute a differential from two snapshots
- `generate_deep_snapshot(...)`: expand contentReferences, choice types, and complex types
- `ExpandedFhirContext`: a `FhirContext` wrapper that materializes and deep-expands snapshots on demand (with caching)

<Tip>
  If you're validating instances, using `ExpandedFhirContext` is typically the
  simplest option: "ask for a StructureDefinition, and you always get a snapshot
  that is deep-expanded enough for runtime checks".
</Tip>

### Example: materialize a profile snapshot

Generate a snapshot when you have a base StructureDefinition (with snapshot) and
a derived StructureDefinition (with differential):

```rust
use ferrum_context::{DefaultFhirContext, FhirContext};
use ferrum_models::StructureDefinition;
use ferrum_snapshot::generate_structure_definition_snapshot;

# async fn demo(base: StructureDefinition, derived: StructureDefinition) -> Result<(), Box<dyn std::error::Error>> {
let ctx = DefaultFhirContext::from_fhir_version_async(None, "R4").await?;

let materialized = generate_structure_definition_snapshot(
  Some(&base),
  &derived,
  &ctx as &dyn FhirContext,
)?;

assert!(materialized.snapshot.is_some());
# Ok(())
# }
```

If you *don't* want to manage base resolution and deep expansion manually, wrap
your context once:

```rust
use ferrum_context::DefaultFhirContext;
use ferrum_snapshot::ExpandedFhirContext;

#
# async fn demo() -> Result<(), Box<dyn std::error::Error>> {
let ctx = DefaultFhirContext::from_fhir_version_async(None, "R4").await?;
let expanded = ExpandedFhirContext::new(ctx);
let sd = expanded
  .get_structure_definition("http://hl7.org/fhir/StructureDefinition/Patient")?
  .expect("Patient StructureDefinition exists");
# Ok(())
# }
```

## Architecture

Snapshot generation is split into two phases that mirror the FHIR profiling pipeline:

### Phase 1: Shallow snapshot generation

`generate_structure_definition_snapshot` merges a profile's differential onto its
base snapshot. This handles:

- Element inheritance and merging (cardinality, types, bindings, fixed/pattern values)
- Slicing (explicit and implicit), including discriminators and slice ordering
- Recursive profile-on-profile resolution (if the base is itself differential-only, its snapshot is generated on the fly)
- ContentReference expansion (fragment refs like `#Observation.referenceRange` become fully qualified canonicals)
- Type-based child element resolution (e.g. `Location.address.city` resolves through the `Address` StructureDefinition)
- Differential sorting into canonical FHIR order before merging

The result is a **shallow snapshot**: every element from the differential is
correctly merged into the base, but complex-type children are not recursively
inlined.

### Phase 2: Deep expansion

`generate_deep_snapshot` / `SnapshotExpander` takes a shallow snapshot and
recursively inlines children of complex types, resolves contentReferences, and
expands choice-type elements. This produces the fully-expanded snapshot useful
for schema generation and complete element enumeration.

<Info>
  Most use cases (validation, search parameter extraction, UI rendering) work
  fine with shallow snapshots. Deep expansion is primarily needed for full
  element enumeration and schema generation.
</Info>

## How snapshot generation works

Given a base snapshot and a differential, the generator runs these steps:

<Steps>
<Step title="Pre-process">

- Sort the differential into canonical FHIR order (by base snapshot position)
- Validate the differential against the base (path hierarchy, element existence)

</Step>
<Step title="Build merge context">

- Index base elements by `(path, sliceName)` for fast lookup
- Track explicit slicing entries and slice instances
- Detect implicit slicing when slices exist without a slicing entry

</Step>
<Step title="Merge elements">

For each differential element:

- **Existing element**: merge fields using FHIR rules (cardinality restriction, type narrowing, binding strengthening, etc.)
- **New element**: find a base element using a multi-step lookup:
  1. Match by ID in the base snapshot
  2. Match by path in the base snapshot
  3. Resolve through parent element's type (e.g. `Location.address.city` → `Address.city`)
  4. Walk the base chain recursively (`baseDefinition`)
  5. Look up the element's own type StructureDefinition
- **Slices**: insert under the correct slicing entry, respecting ordering rules

</Step>
<Step title="Post-process">

- Normalize `id` and slice identifiers (`path:sliceName`)
- Expand fragment contentReferences to fully qualified canonicals
- Default `slicing.ordered` to `false` when absent
- Propagate parent slice names into child element IDs
- Validate cardinality consistency and slicing discriminators

</Step>
</Steps>

## Deep expansion

FHIR snapshots are already "expanded" in the profiling sense, but they still
contain elements whose effective shape depends on resolving other definitions:

- **Choice types** like `value[x]`
- **Complex types** like `CodeableConcept`, `Identifier`, `BackboneElement`
- **`contentReference`** links that reuse another element subtree

The `SnapshotExpander` inlines those structures to create a "deep snapshot".
Ferrum uses this for validation steps that need to walk actual nested shapes.

### What is expanded

- `contentReference`: copies the referenced element's children under the referencing element (with rewritten IDs/paths)
- Choice types: expands `foo[x]` into `fooQuantity`, `fooString`, etc. based on the declared `type[]`
- Complex types: inlines the referenced type/profile snapshot beneath the element path

### Safety limits

Deep expansion is intentionally conservative to avoid runaway recursion:

- Per-type recursion caps for "circular-prone" types (e.g. `Reference`, `Extension`)
- A maximum depth for contentReference expansion
- Primitives are never expanded

If a referenced StructureDefinition can't be resolved from the `FhirContext`, deep
expansion **skips** that subtree (and emits a warning) instead of failing the
entire operation.

## Caveats

<Warning>
  Snapshot generation is one of the most subtle parts of FHIR tooling. This
  implementation covers the pragmatic subset Ferrum needs today, and it will evolve as
  we hit more real-world profiles.
</Warning>

Key caveats in the current implementation:

- **Not a full spec reimplementation**: merge and slicing behavior is intentionally simplified in places.
- **Shallow snapshots don't inline type children under slices**: the reference implementation inlines all children of complex types under slice entries (e.g. `Location.telecom:phone` gets all `ContactPoint` children). Our generator defers this to the deep expansion phase.
- **Choice-type naming**: the generator uses the direct expansion form (`Observation.effectivePeriod`) rather than slice notation (`Observation.effective[x]:effectivePeriod`). Both are valid.
- **No URL version tagging**: the reference implementation appends `|<fhir-version>` to canonical URLs during generation. We preserve URLs as-is — both forms are valid and terminology servers resolve them identically.
- **Implicit slicing is heuristic**: if slices exist without a slicing entry, the library injects a default slicing definition (discriminator defaults to "value on `url`", rules default to `open`).
- **Constraint propagation is limited**: only slice-name propagation and basic cardinality consistency checks are performed today.
- **Deep expansion is lossy by design**: unresolved types/contentReferences are skipped to keep validation resilient when packages are incomplete.

If you need "authoring-tool identical" snapshots, you should still prefer
pre-generated snapshots from the package toolchain when available.

## Related docs

- Background: [Learn FHIR: Profiles](/learn-fhir/profiles)
- Package distribution: [Learn FHIR: Packages](/learn-fhir/packages), [Server guide: Packages](/server/packages)
- Why this matters: [Learn FHIR: Validation](/learn-fhir/validation)
