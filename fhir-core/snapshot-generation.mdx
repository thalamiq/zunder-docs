---
title: "Snapshot Generation"
description: "Generating and expanding StructureDefinition snapshots with `zunder-snapshot`."
---

<Info>
  Spec reference: [https://hl7.org/fhir/structuredefinition.html](https://hl7.org/fhir/structuredefinition.html)
</Info>

FHIR profiles are usually distributed as [`StructureDefinition`](https://hl7.org/fhir/structuredefinition.html)
resources. Most authoring tools publish **differentials** (only “what changed”),
and may omit snapshots entirely.

Zunder needs snapshots at runtime (validation, schema checks, codegen, etc.), so we
provide a library that can:

- **Generate** a snapshot from `base.snapshot + derived.differential`
- **Generate** a differential by comparing `derived.snapshot` to `base.snapshot`
- **Deep-expand** a snapshot for “nested” validation use cases (choice types, contentReferences, complex types)

This page documents the library and the practical caveats of generating snapshots
outside of an authoring toolchain.

## Where this is needed

Snapshots are the most convenient representation for anything that needs a full
“schema-like” view of a resource type or profile:

- **Validation**: resolve required fields, slicing rules, bindings, and invariants
- **Schema / shape checks**: determine which JSON properties are allowed at each path
- **Code generation**: enumerate elements and their effective types
- **User interfaces**: drive form generation and field hints from a resolved structure

Many packages (especially IGs) ship only differentials, and servers often want
to avoid a build step that precomputes snapshots for every profile up front.

## Terminology (Zunder conventions)

- **Base**: the StructureDefinition referenced by `baseDefinition` (or a core type like `Patient`)
- **Derived**: a profile that constrains a base
- **Differential**: only the constrained/added elements
- **Snapshot**: the “fully merged” element list after applying base + constraints
- **Deep snapshot**: a snapshot expanded so that nested types are inlined (not an official FHIR term)

## The `zunder-snapshot` library

The snapshot generator lives in `zunder/crates/fhir-snapshot` and builds
on:

- `zunder-models` for strongly typed FHIR data structures
- `zunder-context` for resolving base types and referenced StructureDefinitions

### Main entry points

Most callers want one of these:

```
use zunder_snapshot::{
  generate_structure_definition_snapshot,
  generate_structure_definition_differential,
  generate_deep_snapshot,
  ExpandedFhirContext,
};
```

- `generate_structure_definition_snapshot(...)`: merge `base.snapshot` + `derived.differential`
- `generate_structure_definition_differential(...)`: compute a differential from two snapshots
- `generate_deep_snapshot(...)`: expand contentReferences, choice types, and complex types
- `ExpandedFhirContext`: a `FhirContext` wrapper that materializes and deep-expands snapshots on demand (with caching)

<Tip>
  If you’re validating instances, using `ExpandedFhirContext` is typically the
  simplest option: “ask for a StructureDefinition, and you always get a snapshot
  that is deep-expanded enough for runtime checks”.
</Tip>

### Example: materialize a profile snapshot

Generate a snapshot when you have a base StructureDefinition (with snapshot) and
a derived StructureDefinition (with differential):

```
use zunder_context::{DefaultFhirContext, FhirContext};
use zunder_models::StructureDefinition;
use zunder_snapshot::generate_structure_definition_snapshot;

# async fn demo(base: StructureDefinition, derived: StructureDefinition) -> Result<(), Box<dyn std::error::Error>> {
let ctx = DefaultFhirContext::from_fhir_version_async(None, "R4").await?;

let materialized = generate_structure_definition_snapshot(
  Some(&base),
  &derived,
  &ctx as &dyn FhirContext,
)?;

assert!(materialized.snapshot.is_some());
# Ok(())
# }
```

If you *don’t* want to manage base resolution and deep expansion manually, wrap
your context once:

```
use zunder_context::DefaultFhirContext;
use zunder_snapshot::ExpandedFhirContext;

#
# async fn demo() -> Result<(), Box<dyn std::error::Error>> {
let ctx = DefaultFhirContext::from_fhir_version_async(None, "R4").await?;
let expanded = ExpandedFhirContext::new(ctx);
let sd = expanded
  .get_structure_definition("http://hl7.org/fhir/StructureDefinition/Patient")?
  .expect("Patient StructureDefinition exists");
# Ok(())
# }
```

## How snapshot generation works (high level)

Given a base snapshot and a differential, snapshot generation does:

<Steps>
<Step title="1) Validate inputs">

- The base snapshot must have a root element first
- The differential must not introduce a parent path that doesn’t exist in the base (or earlier in the differential)

</Step>
<Step title="2) Build a merge index + slicing context">

- Index base elements by `(path, sliceName)` so differential elements can find their target quickly
- Track explicit slicing entries and slice instances; detect implicit slicing when slices exist without a slicing entry

</Step>
<Step title="3) Merge elements">

- If the differential element matches an existing element, merge fields using FHIR-style rules (cardinality, types, binding, fixed/pattern/defaultValue, etc.)
- If it’s a new element, try to find a reasonable base element using a best-effort lookup (by `id`, then `path`, then base chain, then element type)
- Insert new slices under the correct slicing entry, respecting (simplified) slicing rules

</Step>
<Step title="4) Normalize and post-process">

- Normalize `id` and slice identifiers (`path:sliceName`)
- Propagate parent slice names into child element ids
- Validate basic cardinality consistency and slicing discriminators

</Step>
</Steps>

Under the hood, most of this lives in:

- Merge semantics: `zunder/crates/fhir-snapshot/src/merge.rs`
- Slicing engine: `zunder/crates/fhir-snapshot/src/slicing.rs`
- Normalization: `zunder/crates/fhir-snapshot/src/normalization.rs`
- Validation: `zunder/crates/fhir-snapshot/src/validation.rs`

## Deep expansion (why and what it does)

FHIR snapshots are already “expanded” in the profiling sense, but they still
contain elements whose *effective shape* depends on resolving other definitions:

- **Choice types** like `value[x]`
- **Complex types** like `CodeableConcept`, `Identifier`, `BackboneElement`, …
- **`contentReference`** links that reuse another element subtree

The crate’s `SnapshotExpander` can take a snapshot and inline those structures
to create a “deep snapshot”. Zunder uses this for validation steps that need to
walk actual nested shapes and check unknown properties.

### What is expanded

- `contentReference`: copies the referenced element’s children under the referencing element (with rewritten ids/paths)
- choice types: expands `foo[x]` into `fooQuantity`, `fooString`, … based on the declared `type[]`
- complex types: inlines the referenced type/profile snapshot beneath the element path

### Safety limits

Deep expansion is intentionally conservative to avoid runaway recursion:

- per-type recursion caps for “circular-prone” types (e.g. `Reference`, `Extension`)
- a maximum depth for contentReference expansion
- primitives are never expanded

If a referenced StructureDefinition can’t be resolved from the `FhirContext`, deep
expansion **skips** that subtree (and emits a warning) instead of failing the
entire operation.

## Caveats (read this before depending on exact behavior)

<Warning>
  Snapshot generation is one of the most subtle parts of FHIR tooling. This
  implementation covers the pragmatic subset Zunder needs today, and it will evolve as
  we hit more real-world profiles.
</Warning>

Key caveats in the current implementation:

- **Not a full spec reimplementation**: merge and slicing behavior is intentionally simplified in places.
- **Implicit slicing is heuristic**: if slices exist without a slicing entry, the library injects a default slicing definition (discriminator defaults to “value on `url`”, rules default to `open`).
- **Ordering is best-effort**: the generator preserves base ordering and inserts slices under their entry, but it does not fully canonicalize element order.
- **Constraint propagation is limited**: only slice-name propagation and basic cardinality consistency checks are performed today.
- **Deep expansion is lossy by design**: unresolved types/contentReferences are skipped to keep validation resilient when packages are incomplete.
- **Serialization edge cases**: the generator contains a cleanup step that moves mis-deserialized `fixed*`/`pattern*` fields into the correct locations when multiple `#[serde(flatten)]` fields would otherwise collide.

If you need “authoring-tool identical” snapshots, you should still prefer
pre-generated snapshots from the package toolchain when available.

## Related docs

- Background: [Learn FHIR: Profiles](/learn-fhir/profiles)
- Package distribution: [Learn FHIR: Packages](/learn-fhir/packages), [Server guide: Packages](/server/packages)
- Why this matters: [Learn FHIR: Validation](/learn-fhir/validation)
